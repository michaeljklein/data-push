-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/data-push#readme</a>
@package data-push
@version 0.1.0.0

module Control.Comonad.Cofree2

-- | Example uses:
--   
--   <pre>
--   lines
--   comments
--   strings
--   matched: matched stack
--   spaces
--   alpha
--   numeric
--   symbols
--   build special symbols: ',` etc, into applications
--   
--   add type for unresolved precidence problem including resoltions to applications
--   
--   split into: var, app
--   split into: , incl. derived general resolutions (e.g. (.. (f x)) =&gt; f :: a -&gt; b, x :: a)
--   </pre>
exampleUses :: ()

-- | Scan left, recording results in <a>Env</a>
scanlBicofree :: (c -> a -> c) -> c -> Bicofree Maybe a b -> Maybe (Cofree Maybe (Env c b))

-- | Generate a <a>Bicofree</a> from <a>eitherCofreeMaybe2</a>, then
--   <a>scanlBicofree</a> with <a>foldl</a> over the internal <a>Cofree</a>
pushScanlCofree :: (c -> a -> c) -> c -> Cofree Maybe (Either a b) -> Maybe (Cofree Maybe (Env c (Cofree Maybe b)))

-- | Lines c a = Cofree Maybe (Env c a) Cofree Maybe (Either a b) -&gt;
--   Maybe (Lines c (Cofree Maybe b))
linesCofree :: Enum c => Cofree Maybe (Either a b) -> Maybe (Cofree Maybe (Env c (Cofree Maybe b)))

-- | Lefts are matches
eitherCofreeMaybeP :: (a -> Bool) -> Cofree Maybe a -> Cofree Maybe (Either a a)

-- | Lefts are newlines
eitherCofreeLines :: Comonad f => Cofree Maybe (f Char) -> Cofree Maybe (Either (f Char) (f Char))

-- | Collects spaces
eitherCofreeSpaces :: Comonad f => Cofree Maybe (f Char) -> Cofree Maybe (Either (f Char) (f Char))

-- | Begins when predicate matched, never ends
eitherCofreeMaybeBegin2 :: (a -> a -> Bool) -> Cofree Maybe a -> Cofree Maybe (Either a a)

-- | Lefts are comments (ending the line)
eitherCofreeComment :: Comonad f => Cofree Maybe (f Char) -> Cofree Maybe (Either (f Char) (f Char))

-- | begin starts the Left, end ends it
eitherCofreeMaybeBeginEnd :: (a -> Bool) -> (a -> Bool) -> Cofree Maybe a -> Cofree Maybe (Either a a)

-- | begin starts the Left, end ends it
eitherCofreeMaybeBeginEnd2 :: (a -> Bool) -> (a -> a -> Bool) -> Cofree Maybe a -> Cofree Maybe (Either a a)

-- | Parses a string
eitherCofreeString :: Comonad f => Cofree Maybe (f Char) -> Cofree Maybe (Either (f Char) (f Char))

-- | Use <a>Bicofree</a> to push through a representation of a non-empty
--   list
eitherCofreeMaybe2 :: Cofree Maybe (Either a b) -> Bicofree Maybe (Cofree Maybe a) (Cofree Maybe b)

-- | See <a>fromCofree2</a>
fromBicofree :: Functor f => Bicofree f a a -> Cofree f a

-- | <a>Cofree2</a>, when we don't know whether <tt>a</tt> or <tt>b</tt>
--   occurs first
newtype Bicofree f a b
Bicofree :: Either (Cofree2 f b a) (Cofree2 f a b) -> Bicofree f a b
[runBicofree] :: Bicofree f a b -> Either (Cofree2 f b a) (Cofree2 f a b)

-- | Rewriting <tt>(<a>:&lt;&lt;</a>) -&gt; (<a>:&lt;</a>)</tt> gives
--   <a>Cofree</a>
fromCofree2 :: Functor f => Cofree2 f a a -> Cofree f a

-- | Unwrap two layers of a <a>Cofree2</a> by dropping their values
unwrap2 :: Functor f => Cofree2 f a b -> f (f (Cofree2 f a b))
data Cofree2 f a b
[:<<] :: b -> f (Cofree2 f b a) -> Cofree2 f a b
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Control.Comonad.Cofree2.Bicofree f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Comonad.Cofree2.Bicofree f a)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Control.Comonad.Cofree2.Cofree2 f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Comonad.Cofree2.Cofree2 f a)
instance GHC.Base.Functor f => Control.Comonad.Comonad (Control.Comonad.Cofree2.Cofree2 f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq2 (Control.Comonad.Cofree2.Cofree2 f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord2 (Control.Comonad.Cofree2.Cofree2 f)

module Control.Push

-- | Warning: Incomplete instance
class (Functor f, Functor g) => Part f g
part :: Part f g => f (g a) -> f (f (g a))
class (Functor f, Functor g) => Dart f g
dart :: Dart f g => f (f (g a)) -> f (g (f a))
class (Part f g, Dart f g) => Push f g
push :: Push f g => f (g a) -> f (g (f a))
class (Functor f, Functor g) => Draw f g
draw :: Draw f g => f (g (f a)) -> f (f (g a))
class (Functor f, Functor g) => Bond f g
bond :: Bond f g => f (f (g a)) -> f (g a)
class (Draw f g, Bond f g) => Pull f g
pull :: Pull f g => f (g (f a)) -> f (g a)
newtype GPushedPlus f g h a
GPushedPlus :: (GPushedPlus1 g h f :+: GPushedPlus1 h g f) a -> GPushedPlus f g h a
[runGPushedPlus] :: GPushedPlus f g h a -> (GPushedPlus1 g h f :+: GPushedPlus1 h g f) a
newtype GPushedPlus1 g h f a
GPushedPlus1 :: ((f :.: (g :+: h)) :+: (Maybe :.: g)) a -> GPushedPlus1 g h f a
[runGPushedPlus1] :: GPushedPlus1 g h f a -> ((f :.: (g :+: h)) :+: (Maybe :.: g)) a
newtype NonEmptyT f a
NonEmptyT :: (a, f a) -> NonEmptyT f a
[runNonEmptyT] :: NonEmptyT f a -> (a, f a)
data Pair a
Pair :: !a -> !a -> Pair a
[pairFst] :: Pair a -> !a
[pairSnd] :: Pair a -> !a

-- | <a>Push</a> one <a>Functor</a> through another.
--   
--   The goal-function is <a>push</a>, which pushes a "layer" (<a>part</a>)
--   of the outer <a>Functor</a> (<tt>f</tt>) "over" or "through"
--   (<tt>pver</tt>) the inner <a>Functor</a> (<tt>g</tt>).
--   
--   Some experiements and scratch-work proofs demonstrate that there are
--   plenty of "exotic" cases, where ignoring <a>part</a> and <tt>pver</tt>
--   cause one's intuition about pushing one <a>Functor</a> through another
--   to break down.
--   
--   For example, <a>Either</a> has multiple, simple implementations:
--   
--   <ol>
--   <li>Requiring <a>Monad</a>, even though <a>Applicative</a> would be
--   enough for this implementation:</li>
--   </ol>
--   
--   <pre>
--   fmap (fmap return) :: (Functor f, Functor g, Monad m) =&gt; f         (g b) -&gt; f         (g (m         b))
--   fmap (fmap return) :: (Functor f, Functor g)          =&gt; f         (g b) -&gt; f         (g (Either a' b))
--   fmap (fmap return) ::             Functor g           =&gt; Either a' (g b) -&gt; Either a' (g (Either a' b)) -- Note that t' does not have to be equivalent to t
--   push               ::             Functor g           =&gt; Either a  (g b) -&gt; Either a  (g (Either a' b))
--   push               ::             Functor g           =&gt; Either a  (g b) -&gt; Either a  (g (Either a  b))
--   </pre>
--   
--   <ol>
--   <li>Specializing (probably "too early") to <a>Right</a> since
--   <a>return</a> seemed too abstract:</li>
--   </ol>
--   
--   <pre>
--   fmap (fmap Right) :: (Functor f, Functor g) =&gt; f         (g b) -&gt; f         (g (Either a b))
--   fmap (fmap Right) ::             Functor g  =&gt; Either a' (g b) -&gt; Either a' (g (Either a b))
--   fmap (fmap Right) ::             Functor g  =&gt; Either a  (g b) -&gt; Either a  (g (Either a b))
--   push              ::             Functor g  =&gt; Either a  (g b) -&gt; Either a  (g (Either a b))
--   </pre>
--   
--   <ol>
--   <li>Trying out specializing the left <a>fmap</a> first instead, i.e.
--   outermost specialization (right to left), instead of the innermost
--   specialization (left to right) found in 1. and 2.).</li>
--   </ol>
--   
--   <pre>
--   either Left (return . fmap return) :: (Functor g, Monad m) =&gt; Either a' (g a) -&gt; Either a' (g (m        b))
--   either Left (Right  . fmap return) :: (Functor g, Monad m) =&gt; Either a' (g a) -&gt; Either a' (g (m        b))
--   either Left (return . fmap return) ::  Functor g           =&gt; Either a' (g b) -&gt; Either a' (g (Either a b))
--   either Left (return . fmap Right ) ::  Functor g           =&gt; Either a' (g b) -&gt; Either a' (g (Either a b))
--   either Left (Right  . fmap Right ) ::  Functor g           =&gt; Either a' (g b) -&gt; Either a' (g (Either a b))
--   either Left (Right  . fmap Right ) ::  Functor g           =&gt; Either a  (g b) -&gt; Either a  (g (Either a b))
--   push                               ::  Functor g           =&gt; Either a  (g b) -&gt; Either a  (g (Either a b))
--   </pre>
--   
--   Misc. notes:
--   
--   <pre>
--   t a
--   substructure (t a)
--   
--   Ahh! For a (substructure -&gt; Bool) partition into (True substructures, False substructures), this is just a push-through!
--   
--   - What about for (substructure -&gt; Int)?
--   - Or (substructure -&gt; poset)?
--   - Or (substructure -&gt; set)?
--   
--   For a continuous, linear functor, (substructure -&gt; [0,1::Real]) gives us a weighted filter on the functor.
--   
--   In theory, this could be used to factor sounds:
--   - The continuous linear functor is a representation of the song's wave and the partition function is a recognizer
--    (it outputs the percent certainty that a wave clip is in a given class).
--   
--   - Then, one can pull out (weighted) the matching and non-matching parts.
--     * By reducing the intensity of subsections in proportion, inverse proportion resp.
--       to the liklihood, we could derive an approximation of the removal, matching parts resp. of the matched sound(s).
--   </pre>
notes :: ()
instance GHC.Base.Functor Control.Push.Pair
instance GHC.Read.Read a => GHC.Read.Read (Control.Push.Pair a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Push.Pair a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Push.Pair a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Push.Pair a)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Push.NonEmptyT f)
instance (GHC.Read.Read (f a), GHC.Read.Read a) => GHC.Read.Read (Control.Push.NonEmptyT f a)
instance (GHC.Show.Show (f a), GHC.Show.Show a) => GHC.Show.Show (Control.Push.NonEmptyT f a)
instance (GHC.Classes.Ord (f a), GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Push.NonEmptyT f a)
instance (GHC.Classes.Eq (f a), GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Push.NonEmptyT f a)
instance (GHC.Base.Functor f, GHC.Base.Functor h, GHC.Base.Functor g) => GHC.Base.Functor (Control.Push.GPushedPlus1 g h f)
instance GHC.Generics.Generic1 (Control.Push.GPushedPlus1 g h f)
instance GHC.Generics.Generic (Control.Push.GPushedPlus1 g h f a)
instance GHC.Base.Applicative Control.Push.Pair
instance (Control.Push.Push g h, Control.Push.Push f h, Control.Push.Pull f g, Control.Push.Pull g f) => Control.Push.Dart (f GHC.Generics.:.: g) h
instance (Control.Push.Dart f g, Control.Push.Pull f g, Control.Push.Push f h) => Control.Push.Dart f (g GHC.Generics.:.: h)
instance (Control.Push.Push f g, Control.Push.Push f h, Control.Push.Push g h, Control.Push.Pull f g, Control.Push.Pull g f) => Control.Push.Push (f GHC.Generics.:.: g) h
instance (Control.Push.Push f h, Control.Push.Push f g, Control.Push.Pull f g) => Control.Push.Push f (g GHC.Generics.:.: h)
instance (Control.Push.Dart f g, Control.Push.Draw f h, Control.Push.Draw g h, Control.Push.Draw f g, Control.Push.Push f g, Control.Push.Pull f h) => Control.Push.Draw (f GHC.Generics.:.: g) h
instance (Control.Push.Draw f g, Control.Push.Push f g, Control.Push.Pull f h) => Control.Push.Draw f (g GHC.Generics.:.: h)
instance (Control.Push.Pull f g, Control.Push.Pull g f, GHC.Base.Functor h) => Control.Push.Bond (f GHC.Generics.:.: g) h
instance (Control.Push.Pull f g, Control.Push.Pull f h, Control.Push.Pull g h, Control.Push.Pull g f, Control.Push.Pull f (g GHC.Generics.:.: h), Control.Push.Push f g) => Control.Push.Pull (f GHC.Generics.:.: g) h
instance (Control.Push.Pull f h, Control.Push.Pull g h) => Control.Push.Pull (f GHC.Generics.:+: g) h
instance (Control.Push.Pull f g, Control.Push.Pull f h, Control.Push.Push f g) => Control.Push.Pull f (g GHC.Generics.:.: h)
instance (Control.Push.Bond f h, Control.Push.Bond g h) => Control.Push.Bond (f GHC.Generics.:+: g) h
instance (Control.Push.Bond f g, GHC.Base.Functor h) => Control.Push.Bond f (g GHC.Generics.:.: h)
instance (Control.Push.Draw f h, Control.Push.Draw g h) => Control.Push.Draw (f GHC.Generics.:+: g) h
instance (Control.Push.Push f g, Control.Push.Part g h) => Control.Push.Part (f GHC.Generics.:.: g) h
instance (Control.Push.Push f h, Control.Push.Push g h) => Control.Push.Push (f GHC.Generics.:+: g) h
instance (Control.Push.Push f g, Control.Push.Push f h, GHC.Base.Applicative f) => Control.Push.Push f (g GHC.Generics.:*: h)
instance (Control.Push.Push f h, Control.Push.Push g h, Data.Traversable.Traversable f, Data.Traversable.Traversable g, GHC.Base.Applicative h) => Control.Push.Push (f GHC.Generics.:*: g) h
instance Control.Push.Push f g => Control.Push.Push (GHC.Generics.M1 i c f) g
instance Control.Push.Push f g => Control.Push.Push f (GHC.Generics.M1 i c g)
instance (Control.Push.Push f g, Control.Push.Dart (GHC.Generics.M1 i c f) (GHC.Generics.M1 j d g)) => Control.Push.Push (GHC.Generics.M1 i c f) (GHC.Generics.M1 j d g)
instance GHC.Base.Functor f => Control.Push.Push (GHC.Generics.K1 i c) f
instance GHC.Base.Monad f => Control.Push.Push f (GHC.Generics.K1 i c)
instance GHC.Base.Functor f => Control.Push.Push (Data.Functor.Const.Const c) f
instance GHC.Base.Monad f => Control.Push.Push f (Data.Functor.Const.Const c)
instance GHC.Base.Functor f => Control.Push.Push GHC.Generics.U1 f
instance GHC.Base.Monad f => Control.Push.Push f GHC.Generics.U1
instance GHC.Base.Functor f => Control.Push.Push Data.Functor.Identity.Identity f
instance GHC.Base.Monad f => Control.Push.Push f Data.Functor.Identity.Identity
instance GHC.Base.Functor f => Control.Push.Push GHC.Generics.Par1 f
instance GHC.Base.Monad f => Control.Push.Push f GHC.Generics.Par1
instance Control.Push.Push f g => Control.Push.Push (GHC.Generics.Rec1 f) g
instance Control.Push.Push f g => Control.Push.Push f (GHC.Generics.Rec1 g)
instance (Control.Push.Push [] g, Control.Push.Push [] h) => Control.Push.Push [] (g GHC.Generics.:+: h)
instance (Control.Push.Dart f h, Control.Push.Dart g h) => Control.Push.Dart (f GHC.Generics.:+: g) h
instance (Control.Push.Dart f g, Control.Push.Dart f h, GHC.Base.Applicative f) => Control.Push.Dart f (g GHC.Generics.:*: h)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g, GHC.Base.Applicative h) => Control.Push.Dart (f GHC.Generics.:*: g) h
instance (Control.Push.Dart [] g, Control.Push.Dart [] h) => Control.Push.Dart [] (g GHC.Generics.:+: h)
instance Control.Push.Dart f g => Control.Push.Dart (GHC.Generics.M1 i c f) g
instance Control.Push.Dart f g => Control.Push.Dart f (GHC.Generics.M1 i c g)
instance Control.Push.Dart f g => Control.Push.Dart (GHC.Generics.M1 i c f) (GHC.Generics.M1 i c g)
instance GHC.Base.Functor f => Control.Push.Dart (GHC.Generics.K1 i c) f
instance GHC.Base.Monad f => Control.Push.Dart f (GHC.Generics.K1 i c)
instance GHC.Base.Functor f => Control.Push.Dart (Data.Functor.Const.Const c) f
instance GHC.Base.Monad f => Control.Push.Dart f (Data.Functor.Const.Const c)
instance GHC.Base.Functor f => Control.Push.Dart GHC.Generics.U1 f
instance GHC.Base.Monad f => Control.Push.Dart f GHC.Generics.U1
instance GHC.Base.Functor f => Control.Push.Dart Data.Functor.Identity.Identity f
instance GHC.Base.Functor f => Control.Push.Dart f Data.Functor.Identity.Identity
instance GHC.Base.Functor f => Control.Push.Dart GHC.Generics.Par1 f
instance GHC.Base.Functor f => Control.Push.Dart f GHC.Generics.Par1
instance Control.Push.Dart f g => Control.Push.Dart (GHC.Generics.Rec1 f) g
instance Control.Push.Dart f g => Control.Push.Dart f (GHC.Generics.Rec1 g)
instance (Control.Push.Part f g, GHC.Base.Functor h) => Control.Push.Part f (g GHC.Generics.:.: h)
instance (Control.Push.Part f h, Control.Push.Part g h) => Control.Push.Part (f GHC.Generics.:+: g) h
instance (Control.Push.Part f g, Control.Push.Part f h, GHC.Base.Applicative f) => Control.Push.Part f (g GHC.Generics.:*: h)
instance (Control.Push.Part f h, Control.Push.Part g h) => Control.Push.Part (f GHC.Generics.:*: g) h
instance (Control.Push.Part [] g, Control.Push.Part [] h) => Control.Push.Part [] (g GHC.Generics.:+: h)
instance Control.Push.Part f g => Control.Push.Part (GHC.Generics.M1 i c f) g
instance Control.Push.Part f g => Control.Push.Part f (GHC.Generics.M1 i c g)
instance Control.Push.Part f g => Control.Push.Part (GHC.Generics.M1 i c f) (GHC.Generics.M1 j d g)
instance GHC.Base.Functor f => Control.Push.Part (GHC.Generics.K1 i c) f
instance GHC.Base.Monad f => Control.Push.Part f (GHC.Generics.K1 i c)
instance GHC.Base.Functor f => Control.Push.Part (Data.Functor.Const.Const c) f
instance GHC.Base.Monad f => Control.Push.Part f (Data.Functor.Const.Const c)
instance GHC.Base.Functor f => Control.Push.Part GHC.Generics.U1 f
instance GHC.Base.Monad f => Control.Push.Part f GHC.Generics.U1
instance GHC.Base.Functor f => Control.Push.Part Data.Functor.Identity.Identity f
instance GHC.Base.Monad f => Control.Push.Part f Data.Functor.Identity.Identity
instance GHC.Base.Functor f => Control.Push.Part GHC.Generics.Par1 f
instance GHC.Base.Monad f => Control.Push.Part f GHC.Generics.Par1
instance Control.Push.Part f g => Control.Push.Part (GHC.Generics.Rec1 f) g
instance Control.Push.Part f g => Control.Push.Part f (GHC.Generics.Rec1 g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:+: g)

module Control.Push2

-- | <a>Right</a> when the predicate returns <a>True</a>
pushP2 :: Push2 f Either => (a -> Bool) -> f a -> Pushed2 f Either (Either (f a) (f a))

-- | <a>fmap</a> and <a>push2</a>
pmap2 :: Push2 f g => (a -> g b c) -> f a -> Pushed2 f g (g (f b) (f c))

-- | Push through a binary functor (<a>Bifunctor</a>)
class (Functor f, Bifunctor g) => Push2 f g where {
    type family Pushed2 f g a :: *;
}
pushed2 :: Push2 f g => Pushed2 f g a -> Const (f a) (g a)
part2 :: Push2 f g => f (g a b) -> f (f (g a b))
pver2 :: Push2 f g => f (f (g a b)) -> Pushed2 f g (g (f a) (f b))

-- | push2 = pver2 . part2
push2 :: Push2 f g => f (g a b) -> Pushed2 f g (g (f a) (f b))

-- | A witness to the fact that the innermost <tt>f</tt>'s in <tt>Pushed2 f
--   (g (f a) (f b))</tt> is inhabited
push21 :: Push2 f g => f (g a b) -> Pushed2 f g (g a b)

module Data.Btree
data Btree a
Bnil :: Btree a
Bnode :: a -> Btree a -> Btree a -> Btree a
[bnode] :: Btree a -> a
[bnodel] :: Btree a -> Btree a
[bnoder] :: Btree a -> Btree a

-- | Helpers
toTree :: Btree a -> Maybe (Tree a)
toForest :: Btree a -> Forest a

-- | Generate a <a>Btree</a> of constant depth:
--   
--   <pre>
--   constDepth 1 = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--   constDepth 2 =
--     Bnode
--       { bnode = 2
--       , bnodel = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--       , bnoder = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--       }
--   constDepth 3 =
--     Bnode
--       { bnode = 3
--       , bnodel =
--           Bnode
--             { bnode = 2
--             , bnodel = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--             , bnoder = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--             }
--       , bnoder =
--           Bnode
--             { bnode = 2
--             , bnodel = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--             , bnoder = Bnode {bnode = 1, bnodel = Bnil, bnoder = Bnil}
--             }
--       }
--   </pre>
--   
--   A quick search finds the sizes on OEIS: <a>http://oeis.org/A000225</a>
--   <tt> λ&gt; all (n -&gt; 2^n-1 == (length . constDepth) n) [1..20 ::
--   Int] True (1.53 secs, 1,342,668,640 bytes)constDepth :: (Enum a, Ord
--   a) =&gt; a -&gt; Btree a </tt>
constDepth :: (Enum a, Ord a) => a -> Btree a
instance GHC.Generics.Generic1 Data.Btree.Btree
instance GHC.Generics.Generic (Data.Btree.Btree a)
instance GHC.Base.Functor Data.Btree.Btree
instance GHC.Show.Show a => GHC.Show.Show (Data.Btree.Btree a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Btree.Btree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Btree.Btree a)
instance Data.Foldable.Foldable Data.Btree.Btree
instance Data.Traversable.Traversable Data.Btree.Btree
instance GHC.Base.Applicative Data.Btree.Btree

module Data.Btree1
data Btree1 a
Bnode1 :: a -> Btree a -> Btree a -> Btree1 a
[bnode1] :: Btree1 a -> a
[bnodel1] :: Btree1 a -> Btree a
[bnoder1] :: Btree1 a -> Btree a

-- | Helpers
fromBtree :: Btree a -> Maybe (Btree1 a)
toBtree :: Btree1 a -> Btree a
instance GHC.Generics.Generic1 Data.Btree1.Btree1
instance GHC.Generics.Generic (Data.Btree1.Btree1 a)
instance GHC.Base.Functor Data.Btree1.Btree1
instance GHC.Show.Show a => GHC.Show.Show (Data.Btree1.Btree1 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Btree1.Btree1 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Btree1.Btree1 a)
instance GHC.Base.Applicative Data.Btree1.Btree1
instance Control.Comonad.Comonad Data.Btree1.Btree1
instance Data.Foldable.Foldable Data.Btree1.Btree1
instance Data.Traversable.Traversable Data.Btree1.Btree1

module Data.End
class HasEnd f
end :: HasEnd f => f e a -> e
instance Data.End.HasEnd (,)

module Data.Btree.End
data EndBtree e a
Ebnil :: e -> EndBtree e a
Ebnode :: a -> EndBtree e a -> EndBtree e a -> EndBtree e a
[ebnode] :: EndBtree e a -> a
[ebnodel] :: EndBtree e a -> EndBtree e a
[ebnoder] :: EndBtree e a -> EndBtree e a
instance GHC.Generics.Generic1 (Data.Btree.End.EndBtree e)
instance GHC.Generics.Generic (Data.Btree.End.EndBtree e a)
instance GHC.Base.Functor (Data.Btree.End.EndBtree e)
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Data.Btree.End.EndBtree e a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord e) => GHC.Classes.Ord (Data.Btree.End.EndBtree e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.Btree.End.EndBtree e a)
instance Data.End.HasEnd Data.Btree.End.EndBtree
instance Data.Bifunctor.Bifunctor Data.Btree.End.EndBtree
instance Data.Biapplicative.Biapplicative Data.Btree.End.EndBtree
instance Data.Bifoldable.Bifoldable Data.Btree.End.EndBtree
instance Data.Bitraversable.Bitraversable Data.Btree.End.EndBtree
instance Data.Foldable.Foldable (Data.Btree.End.EndBtree e)
instance Data.Traversable.Traversable (Data.Btree.End.EndBtree e)

module Data.Btree1.End
data EndBtree1 e a
Ebnode1 :: a -> EndBtree e a -> EndBtree e a -> EndBtree1 e a
[ebnode1] :: EndBtree1 e a -> a
[ebnodel1] :: EndBtree1 e a -> EndBtree e a
[ebnoder1] :: EndBtree1 e a -> EndBtree e a
toEndBtree1 :: EndBtree e a -> Either e (EndBtree1 e a)
fromEndBtree1 :: EndBtree1 e a -> EndBtree e a
instance GHC.Generics.Generic1 (Data.Btree1.End.EndBtree1 e)
instance GHC.Generics.Generic (Data.Btree1.End.EndBtree1 e a)
instance GHC.Base.Functor (Data.Btree1.End.EndBtree1 e)
instance (GHC.Classes.Ord e, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Btree1.End.EndBtree1 e a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Btree1.End.EndBtree1 e a)
instance Data.End.HasEnd Data.Btree1.End.EndBtree1
instance Data.Bifunctor.Bifunctor Data.Btree1.End.EndBtree1
instance Data.Biapplicative.Biapplicative Data.Btree1.End.EndBtree1
instance Data.Bifoldable.Bifoldable Data.Btree1.End.EndBtree1
instance Data.Bitraversable.Bitraversable Data.Btree1.End.EndBtree1
instance Data.Foldable.Foldable (Data.Btree1.End.EndBtree1 e)
instance Data.Traversable.Traversable (Data.Btree1.End.EndBtree1 e)
instance Control.Comonad.Comonad (Data.Btree1.End.EndBtree1 e)
instance Control.Comonad.Env.Class.ComonadEnv e (Data.Btree1.End.EndBtree1 e)

module Data.List.End
data EndList e a
End :: e -> EndList e a
(:.) :: a -> (EndList e a) -> EndList e a
fromNonEmptyList :: NonEmpty a -> EndList a a
fromListWithEnd :: e -> [a] -> EndList e a
fromListWithEndF :: (a -> e -> e) -> e -> [a] -> EndList e a
fromListWithEndA :: Applicative f => (a -> f e -> f e) -> f e -> [a] -> f (EndList e a)
ehead :: EndList e a -> a
etail :: EndList e a -> EndList e a
econcat :: Monoid e => EndList e (EndList e a) -> EndList e a
econcatWith :: (e -> e -> e) -> EndList e (EndList e a) -> EndList e a
endListToFree :: EndList e a -> Free ((,) a) e
freeToEndList :: Free ((,) a) e -> EndList e a
endListToFreeM :: Monad m => EndList e a -> FreeT ((,) a) m e
freeToEndListM :: Monad m => FreeT ((,) a) m e -> m (EndList e a)
instance GHC.Generics.Generic1 (Data.List.End.EndList e)
instance GHC.Generics.Generic (Data.List.End.EndList e a)
instance GHC.Base.Functor (Data.List.End.EndList e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord e) => GHC.Classes.Ord (Data.List.End.EndList e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.List.End.EndList e a)
instance Data.End.HasEnd Data.List.End.EndList
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.List.End.EndList e a)
instance Data.Bifunctor.Bifunctor Data.List.End.EndList
instance Data.Biapplicative.Biapplicative Data.List.End.EndList
instance Data.Bifoldable.Bifoldable Data.List.End.EndList
instance Data.Bitraversable.Bitraversable Data.List.End.EndList
instance Data.Foldable.Foldable (Data.List.End.EndList e)
instance Data.Traversable.Traversable (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Applicative (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Alternative (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Monad (Data.List.End.EndList e)
instance GHC.Base.Monoid e => Control.Monad.Zip.MonadZip (Data.List.End.EndList e)
instance GHC.Base.Monoid e => Control.Monad.Fix.MonadFix (Data.List.End.EndList e)

module Data.List.NonEmpty.End
data NonEmptyEnd e a
(:|.) :: a -> (EndList e a) -> NonEmptyEnd e a
fromListWithEnd1 :: e -> NonEmpty a -> NonEmptyEnd e a
fromListWithEnd1F :: (a -> e -> e) -> e -> NonEmpty a -> NonEmptyEnd e a
fromListWithEnd1A :: Applicative f => (a -> f e -> f e) -> f e -> NonEmpty a -> f (NonEmptyEnd e a)
toEndList1 :: NonEmptyEnd e a -> EndList e a
fromEndList1 :: EndList e a -> Either e (NonEmptyEnd e a)
cofreeMaybeToNonEmpty :: Cofree Maybe a -> NonEmpty a
nonEmptyToCofreeMaybe :: NonEmpty a -> Cofree Maybe a
cofreeMaybeToNonEmptyM :: Monad m => Cofree (MaybeT m) a -> m (NonEmpty a)
nonEmptyToCofreeMaybeM :: Monad m => NonEmpty a -> Cofree (MaybeT m) a
cofreeEitherToNonEmptyEnd :: Cofree (Either e) a -> NonEmptyEnd e a
nonEmptyEndToCofreeEither :: NonEmptyEnd e a -> Cofree (Either e) a
cofreeExceptToNonEmptyEnd :: Monad m => Cofree (ExceptT e m) a -> m (NonEmptyEnd e a)
nonEmptyEndToCofreeExcept :: Monad m => NonEmptyEnd e a -> Cofree (ExceptT e m) a
instance GHC.Generics.Generic1 (Data.List.NonEmpty.End.NonEmptyEnd e)
instance GHC.Generics.Generic (Data.List.NonEmpty.End.NonEmptyEnd e a)
instance GHC.Base.Functor (Data.List.NonEmpty.End.NonEmptyEnd e)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.List.NonEmpty.End.NonEmptyEnd e a)
instance (GHC.Classes.Ord e, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.List.NonEmpty.End.NonEmptyEnd e a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.List.NonEmpty.End.NonEmptyEnd e a)
instance Data.End.HasEnd Data.List.NonEmpty.End.NonEmptyEnd
instance Data.Bifunctor.Bifunctor Data.List.NonEmpty.End.NonEmptyEnd
instance Data.Biapplicative.Biapplicative Data.List.NonEmpty.End.NonEmptyEnd
instance Data.Bifoldable.Bifoldable Data.List.NonEmpty.End.NonEmptyEnd
instance Data.Bitraversable.Bitraversable Data.List.NonEmpty.End.NonEmptyEnd
instance Data.Foldable.Foldable (Data.List.NonEmpty.End.NonEmptyEnd e)
instance Data.Traversable.Traversable (Data.List.NonEmpty.End.NonEmptyEnd e)
instance Control.Comonad.Comonad (Data.List.NonEmpty.End.NonEmptyEnd e)
instance Control.Comonad.Env.Class.ComonadEnv e (Data.List.NonEmpty.End.NonEmptyEnd e)

module Data.Tree.End
data EndTree e a
EndNode :: a -> EndForest e a -> EndTree e a
[endRootLabel] :: EndTree e a -> a
[subEndForest] :: EndTree e a -> EndForest e a
newtype EndForest e a
EndForest :: EndList e (EndTree e a) -> EndForest e a
[getEndForet] :: EndForest e a -> EndList e (EndTree e a)
cofreeListToTree :: Cofree [] a -> Tree a
treeToCofreeList :: Tree a -> Cofree [] a
instance GHC.Generics.Generic1 (Data.Tree.End.EndTree e)
instance GHC.Generics.Generic (Data.Tree.End.EndTree e a)
instance GHC.Base.Functor (Data.Tree.End.EndTree e)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.Tree.End.EndTree e a)
instance (GHC.Classes.Ord e, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Tree.End.EndTree e a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Tree.End.EndTree e a)
instance GHC.Generics.Generic1 (Data.Tree.End.EndForest e)
instance GHC.Generics.Generic (Data.Tree.End.EndForest e a)
instance GHC.Base.Functor (Data.Tree.End.EndForest e)
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Data.Tree.End.EndForest e a)
instance (GHC.Classes.Ord e, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Tree.End.EndForest e a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Tree.End.EndForest e a)
instance Data.End.HasEnd Data.Tree.End.EndTree
instance Data.Bifunctor.Bifunctor Data.Tree.End.EndTree
instance Data.Biapplicative.Biapplicative Data.Tree.End.EndTree
instance Data.Bifoldable.Bifoldable Data.Tree.End.EndTree
instance Data.Bitraversable.Bitraversable Data.Tree.End.EndTree
instance Data.Foldable.Foldable (Data.Tree.End.EndTree e)
instance Data.Traversable.Traversable (Data.Tree.End.EndTree e)
instance Control.Comonad.Comonad (Data.Tree.End.EndTree e)
instance Control.Comonad.Env.Class.ComonadEnv e (Data.Tree.End.EndTree e)
instance Data.End.HasEnd Data.Tree.End.EndForest
instance Data.Bifunctor.Bifunctor Data.Tree.End.EndForest
instance Data.Biapplicative.Biapplicative Data.Tree.End.EndForest
instance Data.Bifoldable.Bifoldable Data.Tree.End.EndForest
instance Data.Bitraversable.Bitraversable Data.Tree.End.EndForest
instance Data.Foldable.Foldable (Data.Tree.End.EndForest e)
instance Data.Traversable.Traversable (Data.Tree.End.EndForest e)

module Scratch

-- | <pre>
--   push :: f (Either a b) -&gt; f (Either (f a) (f b))
--   
--   we need to be able to:
--     f a -&gt; f (StronglyConnectedComponent f a)
--   
--   which is two steps:
--     isolate:
--       we need to isolate the SCC
--     constract:
--       we need to replace the SCC with a single node containing the SCC
--   
--   what the end-functor construction does is replace the contraction with an equivalent operation: redefinition of data boundaries
--     with an added bonus: the boundaries are "free", and always result in an isomorphic type (proof?)
--   </pre>
s1 :: ()

-- | <pre>
--   An end-functor is a functor with the following properties:
--     It has an end value, whose type is solely dependent upon f:
--       type EndOf f :: *
--       endOf :: f a -&gt; EndOf f
--       end :: EndOf f -&gt; f a
--       endOf . end == id
--     Its end value may be replaced with a new one, as a result of a fold:
--       Bifunctor (End f)
--       type EndOf (End f e) = e
--       foldEnd :: Fold a (EndOf f -&gt; e) -&gt; f a -&gt; End f e a
--       foldEndM :: Monad m =&gt; FoldM a (EndOf f -&gt; e) -&gt; f a -&gt; m (End f e a)
--     Its middle values may be split by an end, resulting in a duplicate-like operation:
--       foldEnds :: (a -&gt; Bool) -&gt; f a -&gt; FixEnd f a
--       foldEndsM :: Monad m =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (FixEnd f a)
--   
--       FoldM (Either (Left a)) b () -&gt; FoldM (Either (Right b)) a () -&gt; f (Either a b) -&gt; EitherFlip (FixEnd2 f) a b
--   </pre>
endFunctorDef :: ()

-- | <pre>
--   what about:
--     newtype Stream a = Stream { runStream :: (a, Stream a) }
--   we can push it through Either:
--     Stream (Either a b) -&gt; NonEmptyEnd (NonEmptyEnd .. b) a
--   
--   newtype EitherFlip f a b = EitherFlip { getEitherFlip :: Either (f b a) (f a b) } deriving (Eq, Ord, Show, Functor)
--   
--   newtype FixEnd f a = FixEnd { runFixEnd :: End f (FixEnd f a) a }
--   
--   newtype FixEnd2 f a b = FixEnd2 { runFixEnd2 :: End f (FixEnd2 f b a) b }
--   
--   newtype SomeIso a = SomeIso { runSomeIso :: (a -&gt; b, b, b -&gt; a) }
--   </pre>
s2 :: ()
