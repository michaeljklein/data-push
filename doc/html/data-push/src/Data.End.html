<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">End</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-2"></a><span>
</span><a name="line-3"></a><span class="hs-keyword">class</span><span> </span><a name="HasEnd"><a href="Data.End.html#HasEnd"><span class="hs-identifier">HasEnd</span></a></a><span> </span><a name="local-6989586621679068099"><a href="#local-6989586621679068099"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-4"></a><span>  </span><span class="hs-identifier">end</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679068099"><span class="hs-identifier hs-type">f</span></a><span> </span><a href="#local-6989586621679068100"><span class="hs-identifier hs-type">e</span></a><span> </span><a href="#local-6989586621679068101"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679068100"><span class="hs-identifier hs-type">e</span></a><span>
</span><a name="line-5"></a><span>
</span><a name="line-6"></a><span class="hs-keyword">instance</span><span> </span><a href="Data.End.html#HasEnd"><span class="hs-identifier hs-type">HasEnd</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-7"></a><span>  </span><a name="local-8214565720323843009"><a href="Data.End.html#end"><span class="hs-identifier">end</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fst</span><span>
</span><a name="line-8"></a><span>
</span><a name="line-9"></a><span>
</span><a name="line-10"></a><span class="hs-comment">-- data Strict f a = Strict { getStrict :: !(f a) } deriving (Eq, Ord, Show, Functor, Generic, Generic1)</span><span>
</span><a name="line-11"></a><span>
</span><a name="line-12"></a><span class="hs-comment">-- data EndStrict f e a = EndStrict { getEndStrict :: !(Strict f a)</span><span>
</span><a name="line-13"></a><span class="hs-comment">--                                  , endStrictEnd :: !e</span><span>
</span><a name="line-14"></a><span class="hs-comment">--                                  } deriving (Eq, Ord, Show, Functor, Generic, Generic1)</span><span>
</span><a name="line-15"></a><span>
</span><a name="line-16"></a><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span class="hs-comment">-- newtype PairEnded p a b = Either (p (Maybe a) (a, b)) (p (Maybe b) (b, a))</span><span>
</span><a name="line-19"></a><span>
</span><a name="line-20"></a><span class="hs-comment">-- instance (Functor f, Bifunctor p) =&gt; HasEnd f p | f -&gt; p where</span><span>
</span><a name="line-21"></a><span class="hs-comment">--   end :: p e a -&gt; e</span><span>
</span><a name="line-22"></a><span>
</span><a name="line-23"></a><span class="hs-comment">--   foldEnd :: Fold a e -&gt; f a -&gt; p e a</span><span>
</span><a name="line-24"></a><span>
</span><a name="line-25"></a><span class="hs-comment">--   foldEndM :: Monad m =&gt; FoldM m a e -&gt; f a -&gt; m (p e a)</span><span>
</span><a name="line-26"></a><span>
</span><a name="line-27"></a><span class="hs-comment">--   fromEnd :: p e a -&gt; f a</span><span>
</span><a name="line-28"></a><span>
</span><a name="line-29"></a><span class="hs-comment">--   pushEnded :: f (Either a b) -&gt; PairEnded p (f a) (f b)</span><span>
</span><a name="line-30"></a><span>
</span><a name="line-31"></a><span class="hs-comment">--   pushEndedMaybe :: f (Maybe a) -&gt; PairEnded p (f ()) (f a)</span><span>
</span><a name="line-32"></a><span>
</span><a name="line-33"></a><span>
</span><a name="line-34"></a><span class="hs-comment">-- instance HasEnd (Strict f) (EndStrict f) where</span><span>
</span><a name="line-35"></a><span class="hs-comment">--   end = endStrictEnd</span><span>
</span><a name="line-36"></a><span class="hs-comment">--   foldEnd f xs = EndStrict xs (fold f xs)</span><span>
</span><a name="line-37"></a><span class="hs-comment">--   foldEndM f xs = EndStrict xs &lt;$&gt; foldM f xs</span><span>
</span><a name="line-38"></a><span class="hs-comment">--   fromEnd = getEndStrict</span><span>
</span><a name="line-39"></a><span>
</span><a name="line-40"></a><span>
</span><a name="line-41"></a><span>
</span><a name="line-42"></a><span>
</span><a name="line-43"></a><span class="hs-comment">-- instance HasEnd [] EndList</span><span>
</span><a name="line-44"></a><span>
</span><a name="line-45"></a><span class="hs-comment">-- instance HasEnd Tree EndTree</span><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span class="hs-comment">-- instance HasEnd Forest EndForest</span><span>
</span><a name="line-48"></a><span>
</span><a name="line-49"></a><span class="hs-comment">-- instance HasEnd NonEmpty EndNonEmpty</span><span>
</span><a name="line-50"></a><span>
</span><a name="line-51"></a><span class="hs-comment">-- instance HasEnd Btree EndBtree</span><span>
</span><a name="line-52"></a><span>
</span><a name="line-53"></a><span class="hs-comment">-- instance HasEnd Btree1 EndBtree1</span><span>
</span><a name="line-54"></a><span>
</span><a name="line-55"></a><span>
</span><a name="line-56"></a><span>
</span><a name="line-57"></a><span class="hs-comment">-- -- Fold a e -&gt; [a] -&gt; EndList e a</span><span>
</span><a name="line-58"></a><span class="hs-comment">-- -- FoldM m a e -&gt; [a] -&gt; m (EndList e a)</span><span>
</span><a name="line-59"></a><span>
</span><a name="line-60"></a><span>
</span><a name="line-61"></a><span class="hs-comment">-- -- Push maps:</span><span>
</span><a name="line-62"></a><span>
</span><a name="line-63"></a><span class="hs-comment">-- instance (Ord k, Functor f) =&gt; Push (Map k) f where</span><span>
</span><a name="line-64"></a><span class="hs-comment">--   part :: Map k (f a) -&gt; Map k (Map k (f a))</span><span>
</span><a name="line-65"></a><span class="hs-comment">--   {-# INLINE part #-}</span><span>
</span><a name="line-66"></a><span class="hs-comment">--   part = M.mapWithKey M.singleton</span><span>
</span><a name="line-67"></a><span>
</span><a name="line-68"></a><span class="hs-comment">--   dart :: Map k (Map k (f a)) -&gt; Map k (f (Map k a))</span><span>
</span><a name="line-69"></a><span class="hs-comment">--   {-# INLINE dart #-}</span><span>
</span><a name="line-70"></a><span class="hs-comment">--   dart = M.mapWithKey $ \k x -&gt; M.singleton k &lt;$&gt; fromSingleton x</span><span>
</span><a name="line-71"></a><span>
</span><a name="line-72"></a><span class="hs-comment">-- import qualified Data.Map.Internal as IM</span><span>
</span><a name="line-73"></a><span>
</span><a name="line-74"></a><span class="hs-comment">-- fromSingletonMap :: Map k a -&gt; a</span><span>
</span><a name="line-75"></a><span class="hs-comment">-- {-# INLINE fromSingletonMap #-}</span><span>
</span><a name="line-76"></a><span class="hs-comment">-- fromSingletonMap ~(MI.Bin 1 _ x MI.Tip MI.Tip) = x</span><span>
</span><a name="line-77"></a><span>
</span><a name="line-78"></a><span>
</span><a name="line-79"></a><span class="hs-comment">-- instance Functor f =&gt; Push IntMap f where</span><span>
</span><a name="line-80"></a><span class="hs-comment">--   part :: IntMap (f a) -&gt; IntMap (IntMap (f a))</span><span>
</span><a name="line-81"></a><span class="hs-comment">--   {-# INLINE part #-}</span><span>
</span><a name="line-82"></a><span class="hs-comment">--   part = IM.mapWithKey IM.singleton</span><span>
</span><a name="line-83"></a><span>
</span><a name="line-84"></a><span class="hs-comment">--   dart :: IntMap (IntMap (f a)) -&gt; IntMap (f (IntMap a))</span><span>
</span><a name="line-85"></a><span class="hs-comment">--   {-# INLINE dart #-}</span><span>
</span><a name="line-86"></a><span class="hs-comment">--   dart = IM.mapWithKey $ \k x -&gt; IM.singleton k &lt;$&gt; fromSingletonIntMap x</span><span>
</span><a name="line-87"></a><span>
</span><a name="line-88"></a><span>
</span><a name="line-89"></a><span class="hs-comment">-- import qualified Data.IntMap.Internal as IMI</span><span>
</span><a name="line-90"></a><span>
</span><a name="line-91"></a><span class="hs-comment">-- fromSingletonIntMap :: IntMap a -&gt; a</span><span>
</span><a name="line-92"></a><span class="hs-comment">-- {-# INLINE fromSingletonIntMap #-}</span><span>
</span><a name="line-93"></a><span class="hs-comment">-- fromSingletonIntMap ~(IMI.Tip _ x) = x</span><span>
</span><a name="line-94"></a><span>
</span><a name="line-95"></a><span>
</span><a name="line-96"></a><span class="hs-comment">-- -- Push Representable:</span><span>
</span><a name="line-97"></a><span>
</span><a name="line-98"></a><span class="hs-comment">-- instance (Representable f, Semigroup (Key f), Functor g) =&gt; Push (Rep f) g where</span><span>
</span><a name="line-99"></a><span class="hs-comment">--   part :: Rep f (g a) -&gt; Rep f (Rep f (g a))</span><span>
</span><a name="line-100"></a><span class="hs-comment">--   part = duplicatedRep</span><span>
</span><a name="line-101"></a><span>
</span><a name="line-102"></a><span class="hs-comment">--   dart :: Rep f (Rep f (g a)) -&gt; Rep f (g (Rep f a))</span><span>
</span><a name="line-103"></a><span class="hs-comment">--   dart = fmap return . join</span><span>
</span><a name="line-104"></a><span>
</span><a name="line-105"></a><span class="hs-comment">-- instance Representable g =&gt; Part [] (Rep g) where</span><span>
</span><a name="line-106"></a><span class="hs-comment">--   part = fmap (: [])</span><span>
</span><a name="line-107"></a><span>
</span><a name="line-108"></a><span class="hs-comment">-- instance Representable g =&gt; Part Maybe (Rep g) where</span><span>
</span><a name="line-109"></a><span class="hs-comment">--   part = fmap Just</span><span>
</span><a name="line-110"></a><span>
</span><a name="line-111"></a><span class="hs-comment">-- instance Representable g =&gt; Part (Either e) (Rep g) where</span><span>
</span><a name="line-112"></a><span class="hs-comment">--   part = fmap Right</span><span>
</span><a name="line-113"></a><span>
</span><a name="line-114"></a><span>
</span><a name="line-115"></a><span class="hs-comment">-- instance (Functor f, Representable g) =&gt; Dart f (Rep g) where</span><span>
</span><a name="line-116"></a><span class="hs-comment">--   dart :: f (f (Rep g a)) -&gt; f (Rep g (f b))</span><span>
</span><a name="line-117"></a><span class="hs-comment">--   dart = fmap distribute</span><span>
</span><a name="line-118"></a><span>
</span><a name="line-119"></a><span>
</span><a name="line-120"></a><span class="hs-comment">-- -- EndSeq, I'm pretty excited</span><span>
</span><a name="line-121"></a><span>
</span><a name="line-122"></a><span class="hs-comment">-- Seq a -&gt; EndSeq e a</span><span>
</span><a name="line-123"></a><span>
</span><a name="line-124"></a><span class="hs-comment">-- data EndFingerTree e a = EndEmptyT e</span><span>
</span><a name="line-125"></a><span class="hs-comment">--                        | EndSingle a</span><span>
</span><a name="line-126"></a><span class="hs-comment">--                        | EndDeep !Int !(Digit a) (EndFingerTree e (Node a)) !(Digit a)</span><span>
</span><a name="line-127"></a><span>
</span><a name="line-128"></a><span class="hs-comment">-- newtype Seq a = Seq (FingerTree (Elem a))</span><span>
</span><a name="line-129"></a><span>
</span><a name="line-130"></a><span class="hs-comment">-- newtype EndSeq e a = EndSeq (EndFingerTree e (Elem a))</span><span>
</span><a name="line-131"></a><span>
</span><a name="line-132"></a><span>
</span><a name="line-133"></a><span>
</span><a name="line-134"></a><span class="hs-comment">-- -- | Things you can push a sum through</span><span>
</span><a name="line-135"></a><span class="hs-comment">-- class PushSum f where</span><span>
</span><a name="line-136"></a><span class="hs-comment">--   pushMaybe :: f (Maybe a) -&gt; Either2 (Pushed f) (forall t. Maybe t) (Maybe (Pushed1 f a))</span><span>
</span><a name="line-137"></a><span>
</span><a name="line-138"></a><span class="hs-comment">--   pushEither :: f (Either a b) -&gt; Either2 (Pushed f) (forall t. Either a t) (forall t. Either t b)</span><span>
</span><a name="line-139"></a><span>
</span><a name="line-140"></a><span class="hs-comment">-- class PushSum f where</span><span>
</span><a name="line-141"></a><span class="hs-comment">--   type PushedSumEnd f e a :: *</span><span>
</span><a name="line-142"></a><span class="hs-comment">--   pushMaybe :: f (Maybe a) -&gt; EitherFlip (PushedSumEnd f)</span><span>
</span><a name="line-143"></a><span>
</span><a name="line-144"></a><span class="hs-comment">-- newtype SumEnd f a b = SumEnd { getSumEnd :: End f (SumEnd f b a) b } deriving (Eq, Ord, Show, Functor)</span><span>
</span><a name="line-145"></a><span>
</span><a name="line-146"></a><span>
</span><a name="line-147"></a><span>
</span><a name="line-148"></a><span>
</span><a name="line-149"></a></pre></body></html>